# 限制步数井字棋 (Limited Move Tic-Tac-Toe)

## 项目概述

这是一个井字棋变体游戏的实现，核心特点是**每个玩家只能保留最近的N步棋子**。当玩家下的棋子超过N步时，最早放置的棋子会自动消失。这使得游戏更具策略性和动态性。

## 文件说明

### 1. gamebase.py

**基础游戏引擎类 (GameBase)**

这是一个通用的游戏框架，支持自定义棋盘大小和步数限制。

**核心功能：**
- `__init__(n, max_move)`: 初始化n×n棋盘，限制每方最多保留max_move步
- `board`: 二维数组存储棋盘状态（0=空，1=X玩家，-1=O玩家）
- `x` 和 `y`: 使用双端队列(deque)记录两个玩家的棋子位置
- `play(i, j)`: 执行落子操作
  - 自动管理棋子队列，超过max_move时移除最早的棋子
  - 通过历史记录的奇偶性判断当前玩家
- `get_result()`: 判断胜负
  - 检查4个方向（横、竖、两条对角线）
  - 查找是否存在连续max_move个相同棋子
- `make_move()`: 随机AI落子
- `run(agent0, agent1, round_limit, render)`: 运行两个AI代理对战

**关键特性：**
- 棋子会"消失"：当一方下了超过max_move步后，最早的棋子自动从棋盘移除
- 胜利条件：连成max_move个相同棋子（例如3×3棋盘需要连成3个）

### 2. Game.py

**完整博弈树求解实现**

这是一个针对3×3棋盘、3步限制的专门实现，包含完整的博弈树分析和最优AI。

**核心功能：**

**Game 类：**
- 使用位编码(encoding)优化状态表示
  - `code()`: 将棋子位置编码为数字（例如位置[0,4,8]编码为"196"）
  - `msk`: 组合编码 = x_msk * 1000 + y_msk
- `judge()`: 判断胜负
  - 检查横向三连（同一行且连续）
  - 检查纵向三连（同一列）
  - 检查对角线三连（通过中心点4判断）
- `train()`: 构建完整博弈图
  - 枚举所有可能的游戏状态（约100万个状态）
  - 构建状态转移图
  - 使用动态规划求解每个状态的胜负情况
- `ai_make_move()`: 基于预计算的最优策略选择落子
  - 优先选择必胜策略
  - 必败时选择延长游戏的策略
- `play_with_ai()`: 命令行界面与AI对战

**DiG 类（有向图博弈求解器）：**
- 使用BFS从终局状态反推所有状态的胜负
- `dp[state][player]`: 记录该状态下玩家的胜负情况（1=必胜，-1=必败，0=平局/未定）
- `depth[state][player]`: 记录到达胜利/失败的最短步数
- `solve()`: 核心算法
  - 从已知的胜利/失败状态开始
  - 通过逆向BFS传播胜负信息
  - 如果某状态的所有后继都是对手必胜，则该状态为必败
- `save_training_data()` / `load_training_data()`: 保存/加载预计算结果

**算法原理：**
这是一个经典的**博弈树极小极大值**问题的求解：
- 对于先手玩家，只要存在一个后继状态是必胜，则当前状态必胜
- 对于后手玩家，只有所有后继状态都是必败，当前状态才必败
- 使用BFS保证找到最短获胜路径

### 3. display.py

**图形用户界面 (pygame)**

提供友好的图形界面来玩这个游戏。

**核心功能：**

**GameUI 类：**
- 使用pygame创建游戏窗口
- `draw()`: 绘制游戏界面
  - 棋盘网格
  - X和O棋子（使用渐变色表示新旧程度）
  - 即将消失的棋子显示为半透明
- `draw_x()` / `draw_o()`: 绘制棋子
  - 参数t控制透明度（0=即将消失，1=刚下的新棋）
  - 视觉提示：老棋子颜色更淡
- `handle_events()`: 处理用户交互
  - 鼠标点击棋盘落子
  - 按钮选择游戏模式
- `start_game(player)`: 开始游戏
  - player=0: 玩家执X先手
  - player=1: 玩家执O后手
  - player=-1: 观战模式（可能用于调试）

**视觉特性：**
- 棋子颜色渐变：新下的棋子颜色鲜艳，即将消失的棋子半透明
- 实时显示游戏结果
- 三个按钮："Play with X"、"Play with O"、中间的重置按钮

## 游戏规则

1. **棋盘**：3×3的网格
2. **玩家**：X（红色）vs O（蓝色）
3. **限制**：每个玩家只能保留最近的3步棋子
4. **消失机制**：当你下第4步时，第1步的棋子自动消失
5. **胜利条件**：连成3个相同棋子（横、竖、斜）
6. **AI对手**：使用完整博弈树计算的最优策略

## 运行方式

```bash
# 图形界面版本
python display.py

# 命令行版本（与最优AI对战）
python Game.py
```

## 技术亮点

1. **博弈树完全求解**：通过动态规划预计算所有状态，AI采用最优策略
2. **高效状态编码**：使用数字编码压缩状态空间
3. **双端队列管理**：使用deque高效处理"先进先出"的棋子消失机制
4. **视觉反馈**：通过颜色渐变直观显示棋子的"年龄"

## 策略提示

由于棋子会消失，传统井字棋的"堵住对方"策略会失效。关键是：
- 预判对方即将消失的棋子
- 利用消失机制创造获胜机会
- AI已求解最优策略，很难战胜（除非它没有加载训练数据）

## 依赖项

- Python 3.x
- pygame（用于图形界面）

```bash
pip install pygame
```
